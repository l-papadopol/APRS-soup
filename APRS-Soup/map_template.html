<!DOCTYPE html>
<html>
<!--
Pagina front-end per l'applicazione APRS-Soup
(C) 2025 Papadopol Lucian Ioan - licenza CC BY-NC-ND 3.0 IT
-->
<head>
  <meta charset="utf-8" />
  <title>APRS-Soup</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="leaflet.css" />
  <script src="leaflet.js"></script>
  <style>
    #map { height: 100vh; }
  </style>
</head>
<body>
  <div id="map"></div>
  <script>
    const ssidIcons = {
      "0": "icons/home.png",
      "1": "icons/digipeater.png",
      "3": "icons/car.png",
      "5": "icons/igate.png",
      "6": "icons/weather.png",
      "9": "icons/vehicle.png",
      "14": "icons/truck.png",
      "default": "icons/default.png"
    };

    const map = L.map('map').setView([44.0, 11.5], 6);
    L.tileLayer('/geo/{z}/{x}/{y}.png', {
      minZoom: 4,
      maxZoom: 13,
      attribution: '© OpenStreetMap contributors'
    }).addTo(map);

    let markers = {};
    let trackedStations = {};

    function getIcon(ssid) {
      const iconUrl = ssidIcons[ssid] || ssidIcons["default"];
      return L.icon({
        iconUrl: iconUrl,
        iconSize: [28, 28],
        iconAnchor: [14, 14]
      });
    }

    function formatTime(ts) {
      let d = new Date(ts * 1000);
      return d.toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' });
    }

    function decimalToDMS(value, isLat = true) {
      const cardinal = isLat ? (value >= 0 ? 'N' : 'S') : (value >= 0 ? 'E' : 'W');
      const absValue = Math.abs(value);
      const degrees = Math.floor(absValue);
      const minutesFloat = (absValue - degrees) * 60;
      const minutes = Math.floor(minutesFloat);
      const seconds = ((minutesFloat - minutes) * 60).toFixed(2);
      return `${degrees}° ${minutes}' ${seconds}" ${cardinal}`;
    }

    // Genera il contenuto del popup per una stazione includendo la casella di testo per il messaggio
    function updatePopupContent(callsign, pos) {
      let timeStr = formatTime(pos.timestamp);
      let latDMS = decimalToDMS(pos.lat, true);
      let lonDMS = decimalToDMS(pos.lon, false);
      let latGMaps = pos.lat.toFixed(6);
      let lonGMaps = pos.lon.toFixed(6);
      let isTracked = trackedStations.hasOwnProperty(callsign);
      let checked = isTracked ? "checked" : "";
      return `
        <strong>${callsign}</strong><br>
        Lat: ${latDMS}<br>
        Lon: ${lonDMS}<br>
        Formato G-Maps: ${latGMaps},${lonGMaps}<br>
        Ultimo segnale: ${timeStr}<br>
        <label><input type="checkbox" onchange="toggleTracking('${callsign}', this.checked)" ${checked}> Traccia</label>
        <br>
        <textarea id="msg_${callsign}" placeholder="Inserisci messaggio"></textarea>
        <br>
        <button onclick="sendMessage('${callsign}')">Invia</button>
      `;
    }

    function toggleTracking(callsign, isTracking) {
      if (isTracking) {
        if (!trackedStations[callsign]) {
          let marker = markers[callsign];
          if (marker) {
            let latlng = marker.getLatLng();
            let polyline = L.polyline([latlng], { color: 'blue' }).addTo(map);
            trackedStations[callsign] = { polyline: polyline, positions: [latlng] };
          }
        }
      } else {
        if (trackedStations[callsign]) {
          map.removeLayer(trackedStations[callsign].polyline);
          delete trackedStations[callsign];
        }
      }
    }

    // Invia un messaggio APRS
    async function sendMessage(callsign) {
      let textarea = document.getElementById("msg_" + callsign);
      let message = textarea.value;
      if (!message) {
        alert("Inserisci un messaggio da inviare");
        return;
      }
      let formData = new FormData();
      formData.append("destination", callsign);
      formData.append("message", message);
      try {
        let response = await fetch("/send_message", {
          method: "POST",
          body: formData
        });
        let result = await response.text();
        alert(result);
      } catch (error) {
        alert("Errore nell'invio del messaggio: " + error);
      }
    }

    // Aggiorna la mappa con i nuovi marker presi dal JSON
    async function updateMap() {
      const res = await fetch('/positions.json');
      const data = await res.json();
      for (const [callsign, pos] of Object.entries(data)) {
        if (markers[callsign]) {
          markers[callsign].setLatLng([pos.lat, pos.lon]);
          if (markers[callsign].isPopupOpen()) {
            markers[callsign].setPopupContent(updatePopupContent(callsign, pos));
          }
        } else {
          let marker = L.marker([pos.lat, pos.lon], { icon: getIcon(pos.ssid) }).addTo(map);
          marker.bindPopup(updatePopupContent(callsign, pos));
          markers[callsign] = marker;
          marker.on('click', function() {
            marker.setPopupContent(updatePopupContent(callsign, pos));
          });
        }
        if (trackedStations[callsign]) {
          let latlng = markers[callsign].getLatLng();
          let positions = trackedStations[callsign].positions;
          let lastPoint = positions[positions.length - 1];
          if (!lastPoint || lastPoint.lat !== latlng.lat || lastPoint.lng !== latlng.lng) {
            positions.push(latlng);
            trackedStations[callsign].polyline.setLatLngs(positions);
          }
        }
      }
    }

    setInterval(updateMap, 15000);
    updateMap();
  </script>
</body>
</html>
